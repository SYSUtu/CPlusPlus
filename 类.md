#类
类的基本思想是**数据抽象和封装**。   
`struct Sales_data{`   
`std::string isbn()const{return bookNo;}`   
`Sales_data& combine(const Sales_data&);`   
`double avg_price()const;`   
`std::string bookNo;`   
`unisigned units_sold=0;`   
`double revenue=0.0;`   
`}`
`//非成员接口函数`
`Sales_data add(const Sales_data&,const Sales_data&);`
`std::ostream &print(std::ostream&,const Sales_data&);`
`std::istream &read(std::istream&,Sales_data&);`
##定义成员函数
定义在类内部的函数是隐式的inline函数。尽管所有的成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。**成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this**   
例如，如果调用`total.isbn()`则编译器负责把total的地址传递给isbn的隐式形参this类似`isbn(&total)`。对于我们来说，this形参是隐式定义的。任何自定义名为this的参数或者变量行为都是非法的。我们可以在成员函数内部使用this，但这样是没有必要的。
##const成员函数
isbn函数的另一个关键之处是紧随形参列表之后的const关键字，const的作用是修改隐式this指针de类型。默认情况下，this是指向类类型非常量版本的常量指针，即`Sales_data* const this;`
于是紧跟在参数列表后的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为**常量成员函数**。          
**PS**:如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。   
**io类无法被拷贝，可以通过引用来传递**
##构造函数
构造函数无法被声明为const。类通过一个特殊的构造函数来控制默认初始化的过程，这个函数叫做**默认构造函数**。无需任何实参。  
`struct Sales_data{`   
`std::string isbn()const{return bookNo;}`   
`Sales_data& combine(const Sales_data&);`   
`double avg_price()const;`   
`std::string bookNo;`   
`unisigned units_sold=0;`   
`double revenue=0.0;`   
`}//修改前` 
  
`struct Sales_data{`   
`//新增的构造函数`  
`Sales_data()=default;`   
`Sales_data(const std::string&s):bookNo(s){};`  
`Sales_data(const std::string&s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n){};`
`Sales_data(std::istream&);`  
`//之前的原有成员`   
`std::string isbn()const{return bookNo;}`   
`Sales_data& combine(const Sales_data&);`   
`double avg_price()const;`   
`std::string bookNo;`   
`unisigned units_sold=0;`   
`double revenue=0.0;`   
`}修改后`

`Sales_data()=default;` 表示默认构造函数
`Sales_data(const std::string&s):bookNo(s),units_sold(0),revenue(0){};` 
##访问控制与封装
public：定义在说明符后面的成员在整个程序中可以被访问，public成员定义接口。    
private：说明符后面的成员可以被类的成员函数访问，不能被使用该类的代码访问。   
当我们希望定义的类的所有成员是public时，使用struct；反之使用class。
##友元函数
类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的**友元**。