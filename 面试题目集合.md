## 操作系统
**1.进程和线程**

* 进程是程序的一次执行，包括代码和数据，是CPU分配资源的基本单位，一个进程可以包括多个线程。进程之间通信方式：管道、SOCKET、信号量（互斥、同步）等。子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。线程是独立运行和独立调度的基本单位（线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度），线程之间共享进程的数据空间（借此通信）

**2.进程通信**


**3.进程的调度算法**

**4.文件系统**

**5.内存分配策略**
## 计算机网络
**1.http协议**

* 常见错误代码：   
①200服务器成功返回了网页，成功处理了请求②304未修改，自从上次请求后，请求的页面未被修改过，此时服务器不会返回网页内容，节省带宽和开销③404请求的网页不存在④500服务器内部错误⑤503服务器暂时不可用（超载、停机维护），通常只是暂时状态

**2.TCP与UDP**

* TCP面向连接、可靠的数据传输，有拥塞控制和流量控制，大量数据，速度慢；UDP非连接，不可靠的数据传输，少量数据，速度快
* TCP建立连接的三次握手
* 为什么三次？   
为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
* TCP关闭连接的四次挥手
* TCP如何实现可靠性传输？   
确认机制、重传机制、滑动窗口。
* udp如何实现可靠性传输？   
传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

**2.SOCKET编程**
**3.TCP/IP各层作用**

* 应用层：为操作系统、应用程序提供访问网络的接口（Telnet、FTP、HTTP、SNMP、DNS域名解析）   
传输层：两点之间的根据使用的协议（TCP、UDP），传输相应数据报文   
网络层：整个网络的传输路径选择，路由（IP、RIP）    
网络访问层：数据链路层、物理层的结合，数据链路层相邻节点之间数据帧传输，物理层就是光纤上比特级的数据传输

**4.ping操作原理**
**5.网络层的协议**

* IP协议 根据IP地址决定转发、路由的协议  
ICMP本质理解为带差错报告的IP协议，在主机和路由器之间传递控制信息（网络通不通，主机可不可达，路由可不可达到）   
ARP：将IP地址转化为MAC地址   
RARP：物理地址转为IP地址   
RIP

**6.传输层的协议**

* tcp udp spx

**7.应用层的协议**

* http smtp dns telnet ftp www nfs

**8.DNS的完整流程**

* DNS采用分布式的域名系统，减少故障发生当一个应用需要把主机名解析为IP地址时，该应用程序就会调用解析程序，把待解析的域名放在DNS请求报文中，以UDP数据报 方式发送给本地域名服务器，本地服务器在查找域名后，把对应的IP地址放在回答报文中返回，应用程序获得目的主机的IP地址后即可进行通信。若本地域名服务器不能解析该域名，则向上级域名服务器继续发送查询请求，直到可以解析为止。

![](https://uploadfiles.nowcoder.com/images/20161103/826546_1478161304017_09C4382EB28081822DE5D2454923FAD6)

**9.HTTP1.0/1.1区别**

## c++
* 一定要弄懂c++的内存分配机制，父类，子类继承时的内存如何分配，封装、继承、多态、虚函数的实现机制和原理。
* Strcmp strcpy的返回类型
* C++如何限制类对象只能静态分配或者只能只能动态分配   
动态分配就是用运算符new来创建一个类的对象，在堆上分配内存。   
静态分配就是A a;这样来由编译器来创建一个对象，在栈 上分配内存。
* 实现strcpy()
    
  
  		char * strcpy(char* dest, const char* src)
		{
		assert(dest!=NULL&&src!=NULL);
		char* res=dest;
		while((*dest++=*src++)!=’\0’);
		return res;
		}
* 用内联取代宏：  
1.内联函数在运行时可调试，而宏定义不可以;  
2.编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会；   
3.内联函数可以访问类的成员变量，宏定义则不能；         
4.在类中声明同时定义的成员函数，自动转化为内联函数。 
* 构造函数中可不可以抛出异常？析构函数呢？  
理论上都可以抛出异常。  
但析构函数最好不要抛出异常，将会导致析构不完全，从而有内存泄露    