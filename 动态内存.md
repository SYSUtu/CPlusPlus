# 动态内存
我们的程序到目前为止只使用过静态内存或栈内存。**静态内存**用来保存**局部static对象**，**类static数据成员**以及**定义在函数之外的变量**。**栈内存** 用来保存**定义在函数内的非static对象**。分配在静态或栈内存中的对象由编译器自动创建或销毁。**对于栈对象，仅在其定义的程序中运行时才存在；static对象在使用之前分配，在程序结束时候销毁。** 除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作**自由空间或堆**。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。对象的生存空间由程序来控制，也就是说，当动态空间不再使用的时候，需要显式地销毁。
## 动态内存与静态内存的区别
### 静态内存

静态内存是指在程序开始运行时由编译器分配的内存，它的分配是在程序开始编译时完成的，不占用CPU资源。

程序中的各种变量，在编译时系统已经为其分配了所需的内存空间，当该变量在作用域内使用完毕时，系统会

自动释放所占用的内存空间。

变量的分配与释放，都无须程序员自行考虑。

eg:

基本类型，数组

### 动态内存

用户无法确定空间大小，或者空间太大，栈上无法分配时，会采用动态内存分配。
###区别

a) 静态内存分配在编译时完成，不占用CPU资源; 动态内存分配在运行时，分配与释放都占用CPU资源。

b) 静态内存在栈(stack)上分配; 动态内存在堆(heap)上分配。

c) 动态内存分配需要指针和引用类型支持，静态不需要。

d) 静态内存分配是按计划分配，由编译器负责; 动态内存分配是按需分配，由程序员负责。
## 智能指针
智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种只能指针的区别在于管理底层指针的方式：`shared_ptr`允许多个指针指向同一个对象;`unique_ptr`则独占所指向的对象。   

* `shared_ptr`&`unique_ptr`操作
* shared_ptr<T>sp
* unique_ptr<T>up
* p.get()//返回p中保存的指针
* swap(p,q)
* p.swap(q)
* `shared_ptr`独有的操作
* make_shared<T>(args)
* shared_ptr<T>p(q)//p是q的拷贝；此操作会递增q中的计数器
* p=q
* p.unique()
* p.use_count()

### shared_ptr类

类似vector，智能指针也是模板。  
`shared_ptr<string>p1;`   
可以直接将p1作为条件使用，当p1指向一个对象则为true。

### maek_shared函数

最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。定义在头文件memory中。
`shared_ptr<int>p3=make_shared<int>(42);`
`shared_ptr<string>p4=make_shared<string>(10,'9');`
调用`make_shared<T>`时传递的参数必须与T的构造函数相匹配。   
我们可以认为每个shared_ptr都有一个关联计数器，通常称其为引用计数。    
`auto r=make_shared<int>(42);r=q;`     
递增q指向对象的引用计数，递减r的；若引用计数减为0，则自动释放。

## 直接管理内存

`string *ps1=new string;//默认初始化`
`string *ps=new string();//值初始化` 
`int *p2=new(nothrow)int;//如果分配失败，返回一个空指针`
