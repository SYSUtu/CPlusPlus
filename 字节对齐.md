# 字节对齐
如果体系结构是不对齐的，A中的成员将会一个挨一个存储，从而sizeof(a)为11。显然对齐更浪费了空间。那么为什么要使用对齐呢？
体系结构的对齐和不对齐，是在时间和空间上的一个权衡。对齐节省了时间。假设一个体系结构的字长为w，那么它同时就假设了在这种体系结构上对宽度为w的数据的处理最频繁也是最重要的。它的设计也是从优先提高对w位数据操作的效率来考虑的。    
sizeof的结果怎么来的,请牢记以下3条原则**在没有#pragma pack宏的情况下**

* 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节,则要从４的整数倍地址开始存储。
* 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)
* 收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.

	     typedef struct bb
	     {
	       int id;//[0]....[3]
 	       double weight;//[8].....[15]原则１
 	       float height; //[16]..[19],总长要为８的整数倍,补齐[20]...[23]　　原则３
	      }BB;
         typedef struct aa
         {
            char name[2];     //[0],[1]
             int  id;         //[4]...[7]　原则１
             double score;     //[8]....[15]　　　　
             short grade;    //[16],[17]　　　　　　　　
              BB b; //[24]......[47]　原则２
          }AA;
## #pragma pack()
在代码前加一句#pragma pack(1),你会很高兴的发现,上面的代码输出为
bb是4+8+4=16,aa是2+4+8+2+16=32;这不是理想中的没有内存对齐的世界吗.没错,#pragma pack(1),告诉编译器,所有的对齐都按照1的整数倍对齐,换句话说就是没有对齐规则.
## 对齐值
对于char型数据，其自身对齐值为1，对于short型为2，对于int,float类型，其自身对齐值为4，对于double型，其自身对齐值为8，单位字节。
