# c++ 继承与派生
## 派生类的声明
* 声明一个派生类的一般格式：

　　		class 派生类名:[继承方式] 基类名

　　		{

　　　　　		派生类新增的数据成员和成员函数

　　		};

* 对于上述的格式主要想说一下继承方式的作用，它主要是规定如何访问从基类继承的成员。它可以有关键字private、protected和public来分别表示私有继承、保护继承和公有继承。如果不显示继承方式关键字，系统默认为私有继承。继承方式指定类派生类成员以及类外对象对于从基类继承来的成员的访问权限。
* **派生类继承基类中除构造和析构函数以外的所有成员。**
* 派生类生成：吸收基类成员（除构造析构函数以外的所有成员）；改造基类成员（根据继承方式调整基类成员的访问，函数在子类中的覆盖，以及虚函数在子类中的覆盖）；添加新的成员；
* 派生类中由基类继承而来的成员的初始化工作还是由基类的构造函数完成，然后派生类中新增的成员在派生类的构造函数中初始化。
* 派生类构造函数的语法：

派生类名::派生类名（参数总表）：基类名1（参数表1），基类名（参数名2）....基类名n（参数名n），内嵌子对象1（参数表1），内嵌子对象2（参数表2）....内嵌子对象n（参数表n）
{
    派生类新增成员的初始化语句；
}

* 如果基类中没有不带参数的构造函数，那么在派生类的构造函数中必须调用基类构造函数，以初始化基类成员。
* 派生类构造函数执行的次序：调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左到右）；调用内嵌成员对象的构造函数，调用顺序按照它们在类中声明的顺序；派生类的构造函数体中的内容。


		class B1
		{
		public:
    		B1(int i)
    		{
        		cout<<"constructing B1 "<<i<<endl;
    		}
		};

		class B2
		{
		public:
    		B2(int j)
    		{
        		cout<<"constructing B2 "<<j<<endl;
    		}
		};

		class B3
		{
		public:
    		B3()
    		{
        cout<<"constructing B3"<<endl;
    		}
		};

		class C: public B2, public B1, public B3
		{
		public:
    		C(int a, int b, int c, int d):B1(a), memberB2(d), memberB1(c),B2(b)
    		{

    		}
		private:
    		B1 memberB1;
    		B2 memberB2;
    		B3 memberB3;
		};

		int main() 
		{ 
    		C obj(1,2,3,4);

    		return 0; 
		}
* 这里有几个问题要注意：

首先，这里并没有列出全部基类和成员对象，由于B3类只有默认构造函数，不需要给它传递参数，因此基类B3以及B3类成员对象memberB3就不必列出。

其次，基类名和成员对象名的顺序是随意的。

这个派生类构造函数的函数体为空，可见实际上只是起到了传递参数和调用基类及内嵌对象构造函数的作用。

* 派生类的析构函数的功能是在该对象消亡之前进行一些必要的清理工作，析构函数没有类型，也没有参数。
* 析构函数的执行顺序与构造函数相反。
## 作用域分辨
* 如果某派生类的多个基类拥有同名的成员，同时，派生类又新增这样的同名成员，在这种情况下，派生类成员将覆盖所有基类的同名成员。这就需要这样的调用方式才能调用基类的同名成员。
形式为：基类名::成员名；基类名::成员名（参数表）；
* 如果某个派生类的部分或全部直接基类是从另一个共同的基类派生而来，在这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，因此派生类中也就会产生同名现象，对这种类型的同名成员也要使用作用域分辨符来唯一标识，而且必须用直接基类进行限定。

		class B0
		{
		public:
    		int nV;
    		void fun()
    		{
        		cout<<"member of B0 "<<nV<<endl;
    		}
		};

		class B1:public B0
		{
		public:
    		int nV1;
		};

		class B2:public B0
		{
		public:
    		int nV2;
		};

		class D1:public B1, public B2
		{
		public:
    		int nVd;
    		void fund()
    		{
        		cout<<"member of D1"<<endl;
    		}
		};

		int main() 
		{ 
    		D1 d1;
    		d1.B1::nV = 2;
    		d1.B1::fun();
    		d1.B2::nV = 3;
    		d1.B2::fun();

    		return 0; 
		}
输出结果为：
member of B0 2
member of B0 3
* 在这种情况下，派生类对象在内存中就同时拥有成员nV及fun的两份拷贝。但是很多情况下，我们只需要这样一个这样的数据拷贝，同一成员的多份拷贝增加了内存的开销。可以通过虚函数来解决这个问题。