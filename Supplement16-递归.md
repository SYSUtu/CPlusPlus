# 递归
* 简单的定义: “当函数直接或者间接调用自己时，则发生了递归.”
## 理解递归
* 在初学递归的时候, 看到一个递归实现, 我们总是难免陷入不停的回溯验证之中, 因为回溯就像反过来思考迭代, 这是我们习惯的思维方式, 但是实际上递归不需要这样来验证. 比如, 另外一个常见的例子是阶乘的计算. 阶乘的定义: “一个正整数的阶乘（英语：factorial）是所有小于或等于该数的正整数的积，并且0的阶乘为1。” 以下是Ruby的实现:

		def factorial(n) 
  		if n <= 1 then
    		return 1
  		else
    		return n * factorial(n - 1)
  		end
		end
* Paul Graham提到一种方法, 给我很大启发, 该方法如下:当n=0, 1的时候, 结果正确.假设函数对于n是正确的, 函数对n+1结果也正确.如果这两点是成立的，我们知道这个函数对于所有可能的n都是正确的。
* 这种方法很像数学归纳法, 也是递归正确的思考方式, 事实上, 阶乘的递归表达方式就是1!=1，n!=(n-1)!×n(见wiki). 当程序实现符合算法描述的时候, 程序自然对了, 假如还不对, 那是算法本身错了…… 相对来说, n,n+1的情况为通用情况, 虽然比较复杂, 但是还能理解, 最重要的, 也是最容易被新手忽略的问题在于第1点, 也就是基本用例(base case)要对. 比如, 上例中, 我们去掉if n <= 1的判断后, 代码会进入死循环, 永远不会结束.
## 使用递归
* 上面讲了怎么理解递归是正确的, 同时可以看到在有递归算法描述后, 其实程序很容易写, 那么最关键的问题就是, 我们怎么找到一个问题的递归算法呢?Paul Graham提到, 你只需要做两件事情:你必须要示范如何解决问题的一般情况, 通过将问题切分成有限小并更小的子问题.你必须要示范如何通过有限的步骤, 来解决最小的问题(基本用例).如果这两件事完成了, 那问题就解决了. 因为递归每次都将问题变得更小, 而一个有限的问题终究会被解决的, 而最小的问题仅需几个有限的步骤就能解决.这个过程还是数学归纳法的方法, 只不过和上面提到的一个是验证, 一个是证明.
