#牛客网错题整理

    #include<iostream>
    using namespace std;
    class MyClass
    {
    public:
    MyClass(int i = 0)
    {
        cout << i;
    }
    MyClass(const MyClass &x)
    {
        cout << 2;
    }
    MyClass &operator=(const MyClass &x)
    {
        cout << 3;
        return *this;
    }
    ~MyClass()
    {
        cout << 4;
    }
    };
    int main()
    {
    MyClass obj1(1), obj2(2);
    MyClass obj3 = obj1;
    return 0;
    }运行时的输出结果是（122444）
MyClass obj3 = obj1;   
obj3还不存在，所以调用拷贝构造函数输出2，如果obj3存在，obj3=obj，则调用复制运算符重载函数，输出3


	template<class T> class Foo{
        T tVar;
    public:
        Foo(T t) : tVar(t) { }
	};
 
		template<class T> class FooDerived:public Foo<T>
	{
	};
 
	int main()
	{
    	FooDerived<int> d(5);
   	    return 0;
	}编译错误，可以在FooDerived类中添加一个构造函数解决问题。
定义类模板时，基类如果是需要参数的构造函数时，则须定义显式构造函数。而派生类继承有显式构造函数的基类时，派生类的构造函数也必须显式调用基类的构造函数。

	int f1();
	class T
	{
    	public:static int f2();
   	 private:friend int f3();
    	protect:int f4();
	};
只有类的非静态成员才有this指针

	char str[]=”xunlei”;
	char* p=str;
sizeof(str)= 7，sizeof(p)= 4，sizeof(*p)= 1 。 
   
	设x、y、t均为int型变量，
	则执行语句：t=3; x=y=2; t=x++||++y; 后，变量t和y的值分别为____    
t=x++||++y;  先执行 x++ 然后执行||,最后执行=。由于x=2 根据逻辑运算符可知x++ 理解为true,根据短路运算符可知++y不会执行了。根据逻辑运算可知x++||++y 返回1,则可知t=1;y没有执行，y=2

	#pragma pack(2)
	class BU
	{
    	int number;
    	union UBffer
    {
        char buffer[13];
        int number;
    }ubuf;
   	 	void foo(){}
   	    typedef char*(*f)(void*);
        enum{hdd,ssd,blueray}disk;
	}bu;
    sizeof(bu)的值是(22)