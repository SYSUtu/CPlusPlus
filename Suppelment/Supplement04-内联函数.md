# 内联函数

**inline的原理：代码替代**
在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替代。如果一个函数被指定为inline 函数则它将在程序中每个调用点上被内联地展开：
`int minVal2 = min( i, j );`   
在编译时被展开为:   
`int minVal2 = i < j ? i : j;`   
则把min()写成函数的额外执行开销从而被消除了。   
让一个函数成为内联函数，隐式的为在类里定义函数，显式的则是在函数前加上inline关键字说明。
## 使用inline的一些注意事项

* 从inline的原理，我们可以看出，inline的原理，是**用空间换取时间**的做法，是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。所以，如果**函数体代码过长或者函数体重有循环语句**，if语句或switch语句或递归时，不宜用内联      
* 关键字inline **必须与函数定义体**放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。内联函数调用前必须声明。《高质量C/C++编程》里一个例子。

`inline void Foo(int x, int y);//inline 仅与函数声明放在一起`
`void Foo(int x, int y)`
`{...}//这样是没用的`

`void Foo(int x, int y);`    
`inline void Foo(int x, int y)`
`{...}//正确`


* inline对于编译器来说只是一个建议，编译器可以选择忽略该建议。换句话说，哪怕真的写成了inline，也没有任何错误的情况下，编译器会自动进行优化。所以当inline中出现了递归，循环，或过多代码时，编译器自动无视inline声明，同样作为普通函数调用。
* **总结**：将内联理解为C++中对于函数专有的宏，对于C的函数宏的一种改进。对于常量宏，C++提供const替代；而对于函数宏，C++提供的方案则是inline。在C中，大家都知道宏的优势，编译器通过复制宏代码的方式，省去了参数压栈，生成汇编的call调用，返回参数等操作，虽然存在一些安全隐患，但在效率上，还是很可取的。
## 宏的边界效应

`define MAX(a, b) (a) > (b) ? (a) : (b) `
`result = MAX(i, j) + 2 ; `  
`result = (i) > (j) ? (i) : (j) + 2 ;//执行时候被解释成为这样`

