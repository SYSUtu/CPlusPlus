# 操作符重载
operator是C++的关键字，它和运算符一起使用，表示一个运算符函数，理解时应将operator=整体上视为一个函数名。   
这是C++扩展运算符功能的方法，虽然样子古怪，但也可以理解：一方面要使运算符的使用方法与其原来一致，另一方面扩展其功能只能通过函数的方式（c++中，“功能”都是由函数实现的)。
## 一、为什么使用操作符重载？
对于系统的所有操作符，一般情况下，只支持基本数据类型和标准库中提供的class，对于用户自己定义的class，如果想支持基本操作，比如比较大小，判断是否相等，等等，则需要用户自己来定义关于这个操作符的具体实现。比如，判断两个人是否一样大，我们默认的规则是按照其年龄来比较，所以，在设计person 这个class的时候，我们需要考虑操作符==，而且，根据刚才的分析，比较的依据应该是age。那么为什么叫重载呢？这是因为，在编译器实现的时候，已经为我们提供了这个操作符的基本数据类型实现版本，但是现在他的操作数变成了用户定义的数据类型class，所以，需要用户自己来提供该参数版本的实现。
## 二、如何声明一个重载的操作符？
A:操作符重载实现为类成员函数    
重载的操作符在类体中被声明，声明方式如同普通成员函数一样，只不过他的名字包含关键字operator，以及紧跟其后的一个c++预定义的操作符。
可以用如下的方式来声明一个预定义的==操作符:

    class person{
    private:
        int age;
    public:
    person(int a){
       this->age=a;
    }
    inline bool operator == (const person &ps) const;
    };
实现方式如下：

    inline bool person::operator==(const person &ps) const
    {

     if (this->age==ps.age)
        return true;
     return false;
    }
调用方式如下：

    #include
    using namespace std;
    int main()
	{
  		person p1(10);
  		person p2(20);
  		if(p1==p2) cout<<”the age is equal!”< return 0;
	}

B:操作符重载实现为非类成员函数(全局函数)      
对于全局重载操作符，代表左操作数的参数必须被显式指定。例如： 
 
	#include
	#include
	using namespace std;
	class person
	{
	public:
	int age;
	};

	bool operator==(person const &p1 ,person const & p2)

	//满足要求，做操作数的类型被显示指定
	{
	if(p1.age==p2.age)
	return true;
	return false;
	}

	int main()
	{
	person rose;
	person jack;
	rose.age=18;
	jack.age=23;
	if(rose==jack)
	cout<<"ok"< return 0;
	}  
C:如何决定把一个操作符重载为类成员函数还是全局名字空间的成员呢？  
①如果一个重载操作符是类成员，那么只有当与他一起使用的左操作数是该类的对象时，该操作符才会被调用。如果该操作符的左操作数必须是其他的类型，则操作符必须被重载为全局名字空间的成员。
②C++要求赋值=，下标[]，调用()， 和成员指向-> 操作符必须被定义为类成员操作符。任何把这些操作符定义为名字空间成员的定义都会被标记为编译时刻错误。
③如果有一个操作数是类类型如string类的情形那么对于对称操作符比如等于操作符最好定义为全局名字空间成员。                                                                  