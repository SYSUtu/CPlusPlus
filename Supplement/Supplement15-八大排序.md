# 八大排序
* 排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存

![](http://my.csdn.net/uploads/201207/17/1342514529_5795.jpg)



**当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。   
快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；**
## 插入排序
### 直接插入排序
**基本思想:**将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。   
**要点：**设立哨兵，作为临时存储和判断数组边界之用。   
如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。   
**效率：**时间复杂度：O（n^2）.

		void print(int a[], int n ,int i){  
    		cout<<i <<":";  
    		for(int j= 0; j<8; j++){  
        		cout<<a[j] <<" ";  
    		}  
    		cout<<endl;  
		}  
  
  
		void InsertSort(int a[], int n)  
		{  
    		for(int i= 1; i<n; i++){  
        		if(a[i] < a[i-1]){ //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入  
            		int j= i-1;   
            		int x = a[i]; //复制为哨兵，即存储待排序元素  
            		a[i] = a[i-1]; //先后移一个元素  
            		while(x < a[j]){  //查找在有序表的插入位置  
                		a[j+1] = a[j];  
                		j--;  //元素后移  
            		}  
            		a[j+1] = x; //插入到正确位置  
        		}  
        		print(a,n,i);  //打印每趟排序的结果  
    		}  
      
		}  
  
		int main(){  
    		int a[8] = {3,1,5,7,2,4,9,6};  
    		InsertSort(a,8);  
    		print(a,8,8);  
		} 
### 希尔排序
**基本思想：**先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。
![](http://my.csdn.net/uploads/201207/18/1342577299_5077.jpg)
## 选择排序
### 简单选择排序
**基本思想：**在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。
![](http://my.csdn.net/uploads/201207/18/1342586432_7130.jpg)
### 堆排序
## 交换排序
### 冒泡排序
### 快速排序
**基本思想：**1）选择一个基准元素,通常选择第一个元素或者最后一个元素,2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。3）此时基准元素在其排好序后的正确位置4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。
## 归并排序
**基本思想：**归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。
## 基数排序
