# c++深入理解虚函数
* 面向对象的三大特征：封装，多态，继承。
* 继承：普通虚函数；虚析构函数；纯虚函数；抽象类；接口类；隐藏 vs 覆盖；隐藏与覆盖之间的关系；早绑定和晚绑定；虚函数表
## 什么是多态?
* 面向对象程序设计中的多态性是指向不同的对象发送同一个消息，不同对象对应同一消息产生不同行为。在程序中消息就是调用函数，不同的行为就是指不同的实现方法，即执行不同的函数体。也可以这样说就是实现了“一个接口，多种方法”。
* 从实现的角度来讲，多态可以分为两类：编译时的多态性和运行时的多态性。程序在编译阶段根据参数个数确定调用哪个函数。这种情况叫做静态多态（早绑定）比如：

		class Rect       //矩形类
		{
		public:
    		int calcArea(int width);
    		int calcArea(int width,int height);
		};
* 动态多态是以封装和继承为基础的。
* 那么它们具体是如何体现的呢？**(1)派生类对象直接向基类赋值，赋值效果，基类数据成员和派生类中数据成员的值相同;(2)派生类对象可以初始化基类对象引用;(3)派生类对象的地址可以赋给基类对象的指针;(4)函数形参是基类对象或基类对象的引用，在调用函数时，可以用派生类的对象作为实参;**

		class ABCBase
		{
		private:
        		std::string ABC;    
		public:
        		ABCBase(std::string abc)
        		{
            		ABC=abc;
       		 	}
		void showABC();
		};

		void ABCBase::showABC()
		{
    		std::cout<<"字母ABC=>"<<ABC<<std::endl;
		}

		class X:public ABCBase
		{
		public:
        		X(std::string x):ABCBase(x){}
		};

		void function(ABCBase &base)
		{
		base.showABC();
		}


		int main()
		{
    		ABCBase base("A");
			base.showABC();

    		X x("B");
			base=x;
			base.showABC();

    		ABCBase &base1=x;
    		base1.showABC();
	
    		ABCBase *base2=&x;
    		base2->showABC();

    		function(x);

			return0;
		}
* 紧接着来讲一下虚函数，它允许函数调用与函数体之间的联系在运行时才建立，即在运行时才决定如何动作。
* 和派生类成员覆盖了基类中使用相同名称的成员(派生类对象调用同名成员函数是来自于自己类中成员函数，而非基类中上的)有所不同啊，其实当基类对象指针指向公有派生类的对象时，它只能访问从基类继承下来的成员，而不能访问派生类中定义的成员。但是使用动态指针就是为了表达一种动态调用的性质即当前指针指向哪个对象，就调用那个对象对应类的成员函数。那要怎么来解决的，这时虚函数就体现出了它的作用。其实我们只需要对上一个示例代码中所有的类里出现的showArea()函数声明之前加一个关键字
* 在基类中的某成员函数被声明为虚函数后，在之后的派生类中科以重新来定义它。但定义时，其函数原型，包括返回类型、函数名、参数个数、参数类型的顺序，都必须和基类中的原型完全相同。其实在上述修改后的示例代码里，只要在基类中显式声明了虚函数，那么在之后的派生类中就需要用virtual来显式声明了，可以略去，因为系统会根据其是否和基类中虚函数原型完全相同来判断是不是虚函数。因此，上述派生类中的虚函数如果不显式声明也还是虚函数。
* **虚函数必须是所在类的成员函数，而不能是友元函数，也不能是静态成员函数。因为虚函数调用要靠特定的对象类决定该激活哪一个函数;内联函数不能是虚函数，因为内联函数是不能在运行中动态确定其位置的即使虚函数在类内部定义，编译时将其看作非内联;构造函数不能是虚函数，但析构函数可以是虚函数;**
* 如果在main()主函数中用new建立一个派生类无名对象和定义一个基类对象指针，并将无名对象的地址赋给基类对象指针时，当我们用delete运算符来撤销无名对象时，系统只执行基类析构函数，而不执行派生类析构函数。
* 虽然派生类的析构函数与基类的析构函数名字不同，但是如果将基类的析构函数定义为虚函数，由该基类派生而来的所有派生类的析构函数都自动成为虚函数。

		class Graph
		{
			protected:
			double x;
			double y;
			public:
        		Graph(double x,double y);
				voidvirtual showArea()=0;//定义纯虚函数
		};

		Graph::Graph(double x,double y)
		{
			this->x=x;
			this->y=y;
		}

		virtual 返回类型 函数名(形参表)=0;
* 如果一个类中至少有一个纯虚函数，那么就称该类为抽象类。所以上述中Graph类就是抽象类。对于抽象类有以下几个注意点：(1)抽象类只能作为其他类的基类来使用，不能建立抽象类对象;(2)不允许从具体类中派生出抽象类(不包含纯虚函数的普通类);(3)抽象类不能用作函数的参数类型、返回类型和显示转化类型;(4)如果派生类中没有定义纯虚函数的实现，而只是继承成了基类的纯虚函数。那么该派生类仍然为抽象类。一旦给出了对基类中虚函数的实现，那么派生类就不是抽象类了，而是可以建立对象的具体类;
